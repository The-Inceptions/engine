// Copyright Â© by Jeff Foley 2023-2024. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.
// SPDX-License-Identifier: Apache-2.0

package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/google/uuid"
	"github.com/owasp-amass/config/config"
	"github.com/owasp-amass/engine/api/graphql/server/model"
	et "github.com/owasp-amass/engine/types"
	oam "github.com/owasp-amass/open-asset-model"
	"github.com/owasp-amass/open-asset-model/domain"
	"github.com/owasp-amass/open-asset-model/network"
)

// CreateSession is the resolver for the createSession field.
func (r *mutationResolver) CreateSession(ctx context.Context, input model.CreateSessionInput) (*model.Session, error) {
	testSession := &model.Session{
		SessionToken: "00000000-0000-0000-0000-0000000000033", //?
	}
	return testSession, nil
}

// CreateSessionFromJSON is the resolver for the createSessionFromJson field.
func (r *mutationResolver) CreateSessionFromJSON(ctx context.Context, input model.CreateSessionJSONInput) (*model.Session, error) {
	var config config.Config

	if err := json.Unmarshal([]byte(input.Config), &config); err != nil {
		return nil, err
	}
	// Populate FROM/TO in transformations
	for k, t := range config.Transformations {
		t.Split(k)
	}

	session, err := r.Manager.NewSession(&config)
	if err != nil {
		return nil, err
	}

	return &model.Session{SessionToken: session.ID().String()}, nil
}

// CreateAsset is the resolver for the createAsset field.
func (r *mutationResolver) CreateAsset(ctx context.Context, input model.CreateAssetInput) (*model.Asset, error) {
	token, _ := uuid.Parse(input.SessionToken)

	session := r.Manager.GetSession(token)
	if session == nil {
		return nil, errors.New("invalid session")
	}

	data, ok := input.Data.(map[string]interface{})
	if !ok {
		return nil, errors.New("failed to cast the asset data")
	}
	atype := data["type"].(string)

	j, err := json.Marshal(input.Data)
	if err != nil {
		return nil, err
	}
	// Unmarshal json into AssetData struct
	assetData := &et.AssetData{
		OAMAsset: createSeedAsset(atype),
	}
	if err := json.Unmarshal(j, assetData); err != nil {
		return nil, err
	}

	dba, err := session.DB().Create(nil, "", assetData.OAMAsset)
	if err != nil {
		return nil, err
	}

	// Create and schedule new event
	event := &et.Event{
		Name:       *input.AssetName,
		Asset:      dba,
		Dispatcher: r.Dispatcher,
		Session:    session,
	}

	if err := r.Dispatcher.DispatchEvent(event); err != nil {
		return nil, errors.New("failed to create asset")
	}

	return &model.Asset{ID: token.String()}, nil
}

// TerminateSession is the resolver for the terminateSession field.
func (r *mutationResolver) TerminateSession(ctx context.Context, sessionToken string) (*bool, error) {
	var result bool
	token, _ := uuid.Parse(sessionToken)

	if r.Manager.GetSession(token) == nil {
		return &result, errors.New("invalid session token")
	}

	result = true
	go r.Manager.CancelSession(token)
	return &result, nil
}

// SessionStats is the resolver for the sessionStats field.
func (r *queryResolver) SessionStats(ctx context.Context, sessionToken string) (*model.SessionStats, error) {
	token, _ := uuid.Parse(sessionToken)

	session := r.Manager.GetSession(token)
	if session == nil {
		return nil, errors.New("invalid session token")
	}

	stats := session.Stats()
	stats.Lock()
	completed := stats.WorkItemsCompleted
	total := stats.WorkItemsTotal
	stats.Unlock()

	return &model.SessionStats{
		WorkItemsCompleted: &completed,
		WorkItemsTotal:     &total,
	}, nil
}

// LogMessages is the resolver for the logMessages field.
func (r *subscriptionResolver) LogMessages(ctx context.Context, sessionToken string) (<-chan *string, error) {
	token, _ := uuid.Parse(sessionToken)
	session := r.Manager.GetSession(token)

	if session != nil {
		session.PubSub().Publish("Channel created")
		ch := session.PubSub().Subscribe()
		return ch, nil
	}
	return nil, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

func createSeedAsset(atype string) oam.Asset {
	switch atype {
	case "FQDN":
		return &domain.FQDN{}
	case "IPAddress":
		return &network.IPAddress{}
	case "Netblock":
		return &network.Netblock{}
	case "ASN":
		return &network.AutonomousSystem{}
	case "RIROrg":
		return &network.RIROrganization{}
	}
	return nil
}
